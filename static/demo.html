<!DOCTYPE html>
<html>
<head>
    <title>Real-time Recommender Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0d1117; color: #f0f6fc; }
        
        .header {
            background: linear-gradient(135deg, #1f6feb 0%, #f85149 100%);
            padding: 20px 0;
            text-align: center;
            color: white;
        }
        
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        
        .control-panel {
            background: #161b22; 
            border: 1px solid #30363d; 
            border-radius: 8px; 
            padding: 20px; 
            margin: 20px 0;
        }
        
        .control-row { 
            display: flex; 
            gap: 15px; 
            align-items: center; 
            margin-bottom: 15px; 
        }
        
        .control-row label { 
            min-width: 100px; 
            font-weight: 600; 
        }
        
        input, select, button { 
            padding: 8px 12px; 
            border: 1px solid #30363d; 
            border-radius: 6px; 
            background: #21262d; 
            color: #f0f6fc; 
            font-size: 14px; 
        }
        
        button { 
            background: #238636; 
            cursor: pointer; 
            transition: background 0.2s; 
        }
        
        button:hover { background: #2ea043; }
        
        button.secondary { 
            background: #1f6feb; 
        }
        
        button.secondary:hover { background: #388bfd; }
        
        .status { 
            padding: 10px; 
            border-radius: 6px; 
            margin: 10px 0; 
            font-weight: 500; 
        }
        
        .status.connected { 
            background: rgba(35, 134, 54, 0.15); 
            border: 1px solid #238636; 
            color: #3fb950; 
        }
        
        .status.disconnected { 
            background: rgba(248, 81, 73, 0.15); 
            border: 1px solid #f85149; 
            color: #ff7b72; 
        }
        
        .recommendations {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .rec-panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .rec-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
        }
        
        .rec-panel.offline::before { background: #7c3aed; }
        .rec-panel.realtime::before { background: #f59e0b; }
        .rec-panel.blended::before { background: #10b981; }
        
        .rec-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .rec-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .badge-offline { background: rgba(124, 58, 237, 0.15); color: #a78bfa; }
        .badge-realtime { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .badge-blended { background: rgba(16, 185, 129, 0.15); color: #34d399; }
        
        .rec-list {
            list-style: none;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .rec-item {
            padding: 8px 0;
            border-bottom: 1px solid #21262d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .rec-item:last-child { border-bottom: none; }
        
        .movie-title {
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .movie-score {
            background: #21262d;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 8px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .loading {
            text-align: center;
            color: #8b949e;
            font-style: italic;
            padding: 40px;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .pulse { animation: pulse 2s infinite; }
        
        .event-log {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
        }
        
        .event-entry {
            margin: 5px 0;
            padding: 3px 0;
        }
        
        .event-timestamp {
            color: #8b949e;
            margin-right: 8px;
        }
        
        .event-genre {
            background: #1f6feb;
            padding: 1px 4px;
            border-radius: 2px;
            margin: 0 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé¨ Real-time Movie Recommender</h1>
        <p>Lambda Architecture with Offline + Realtime Blending</p>
    </div>

    <div class="container">
        <div class="control-panel">
            <h2>Demo Controls</h2>
            
            <div class="control-row">
                <label for="userId">User ID:</label>
                <input type="number" id="userId" value="1" min="1">
                <label for="topK">Top K:</label>
                <input type="number" id="topK" value="10" min="1" max="50">
                <button onclick="fetchRecommendations()">Get Recommendations</button>
            </div>
            
            <div class="control-row">
                <label for="genreSelect">Simulate Click:</label>
                <select id="genreSelect">
                    <option value="Action">Action</option>
                    <option value="Comedy">Comedy</option>
                    <option value="Drama">Drama</option>
                    <option value="Horror">Horror</option>
                    <option value="Romance">Romance</option>
                    <option value="Thriller">Thriller</option>
                    <option value="Sci-Fi">Sci-Fi</option>
                    <option value="Adventure">Adventure</option>
                </select>
                <button class="secondary" onclick="simulateClick()">Generate Event</button>
                <button class="secondary" onclick="toggleAutoClick()">
                    <span id="autoClickText">Start Auto</span>
                </button>
            </div>
            
            <div id="wsStatus" class="status disconnected">
                ‚ö†Ô∏è WebSocket: Disconnected
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalEvents">0</div>
                <div class="stat-label">Total Events</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="realtimeWeight">0.35</div>
                <div class="stat-label">RT Weight</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="wsMessages">0</div>
                <div class="stat-label">WS Messages</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="lastUpdate">Never</div>
                <div class="stat-label">Last Update</div>
            </div>
        </div>

        <div class="recommendations">
            <div class="rec-panel offline">
                <div class="rec-title">
                    üìä Offline Batch
                    <span class="rec-badge badge-offline">ALS/Matrix Factorization</span>
                </div>
                <ul class="rec-list" id="offlineRecs">
                    <li class="loading">Loading offline recommendations...</li>
                </ul>
            </div>
            
            <div class="rec-panel realtime">
                <div class="rec-title">
                    ‚ö° Real-time Stream  
                    <span class="rec-badge badge-realtime">Kafka + Redis</span>
                </div>
                <ul class="rec-list" id="realtimeRecs">
                    <li class="loading">Waiting for real-time events...</li>
                </ul>
            </div>
            
            <div class="rec-panel blended">
                <div class="rec-title">
                    üéØ Lambda Blended
                    <span class="rec-badge badge-blended">Final Output</span>
                </div>
                <ul class="rec-list" id="blendedRecs">
                    <li class="loading">Select user to see blended results...</li>
                </ul>
            </div>
        </div>

        <div class="event-log">
            <h3>Real-time Event Stream</h3>
            <div id="eventLog"></div>
        </div>
    </div>

    <script>
        let ws = null;
        let autoClickInterval = null;
        let eventCount = 0;
        let wsMessageCount = 0;
        
        // WebSocket connection
        function connectWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    document.getElementById('wsStatus').className = 'status connected';
                    document.getElementById('wsStatus').innerHTML = '‚úÖ WebSocket: Connected';
                };
                
                ws.onmessage = (event) => {
                    wsMessageCount++;
                    document.getElementById('wsMessages').textContent = wsMessageCount;
                    
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                };
                
                ws.onclose = () => {
                    document.getElementById('wsStatus').className = 'status disconnected';
                    document.getElementById('wsStatus').innerHTML = '‚ö†Ô∏è WebSocket: Disconnected';
                    // Reconnect after 3 seconds
                    setTimeout(connectWebSocket, 3000);
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            } catch (error) {
                console.error('Failed to connect WebSocket:', error);
                setTimeout(connectWebSocket, 3000);
            }
        }
        
        function handleWebSocketMessage(data) {
            if (data.type === 'event') {
                addEventLog(data.user_id, data.item_id, data.genre, data.timestamp);
            } else if (data.type === 'stats') {
                updateStats(data);
            }
            
            // Auto refresh if current user matches
            const currentUserId = parseInt(document.getElementById('userId').value);
            if (data.user_id === currentUserId) {
                fetchRecommendations();
            }
        }
        
        function addEventLog(userId, itemId, genre, timestamp) {
            const logDiv = document.getElementById('eventLog');
            const time = new Date(timestamp * 1000).toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.className = 'event-entry';
            entry.innerHTML = `
                <span class="event-timestamp">[${time}]</span>
                User <strong>${userId}</strong> clicked item <strong>${itemId}</strong> 
                <span class="event-genre">${genre}</span>
            `;
            
            logDiv.insertBefore(entry, logDiv.firstChild);
            
            // Keep only last 10 entries
            while (logDiv.children.length > 10) {
                logDiv.removeChild(logDiv.lastChild);
            }
        }
        
        function updateStats(data) {
            if (data.total_events) {
                document.getElementById('totalEvents').textContent = data.total_events;
            }
            if (data.realtime_weight !== undefined) {
                document.getElementById('realtimeWeight').textContent = data.realtime_weight;
            }
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }
        
        async function fetchRecommendations() {
            const userId = document.getElementById('userId').value;
            const topK = document.getElementById('topK').value;
            
            try {
                const response = await fetch(`/recommend?user_id=${userId}&k=${topK}`);
                const data = await response.json();
                
                displayRecommendations(data);
                updateStats({
                    realtime_weight: data.realtime_weight,
                    total_events: eventCount
                });
            } catch (error) {
                console.error('Failed to fetch recommendations:', error);
            }
        }
        
        function displayRecommendations(data) {
            // Blended (final output)
            const blendedList = document.getElementById('blendedRecs');
            blendedList.innerHTML = data.items.map((itemId, index) => `
                <li class="rec-item">
                    <span class="movie-title">${data.titles[index]}</span>
                    <span class="movie-score">#${index + 1}</span>
                </li>
            `).join('');
            
            // For demo purposes, show offline vs realtime breakdown
            // This would require separate API endpoints in production
            fetchOfflineOnly(data.user_id);
            fetchRealtimeOnly(data.user_id);
        }
        
        async function fetchOfflineOnly(userId) {
            try {
                // Call API with realtime weight = 0 to get pure offline
                const response = await fetch(`/recommend?user_id=${userId}&k=10&offline_only=true`);
                const data = await response.json();
                
                const offlineList = document.getElementById('offlineRecs');
                offlineList.innerHTML = data.items.map((itemId, index) => `
                    <li class="rec-item">
                        <span class="movie-title">${data.titles[index]}</span>
                        <span class="movie-score">ALS</span>
                    </li>
                `).join('');
            } catch (error) {
                document.getElementById('offlineRecs').innerHTML = '<li class="loading">Error loading offline data</li>';
            }
        }
        
        async function fetchRealtimeOnly(userId) {
            try {
                const response = await fetch(`/realtime-only?user_id=${userId}&k=10`);
                const data = await response.json();
                
                const realtimeList = document.getElementById('realtimeRecs');
                if (data.items && data.items.length > 0) {
                    realtimeList.innerHTML = data.items.map((itemId, index) => `
                        <li class="rec-item">
                            <span class="movie-title">${data.titles[index]}</span>
                            <span class="movie-score">RT</span>
                        </li>
                    `).join('');
                } else {
                    realtimeList.innerHTML = '<li class="loading">No recent genre activity</li>';
                }
            } catch (error) {
                document.getElementById('realtimeRecs').innerHTML = '<li class="loading">Realtime data unavailable</li>';
            }
        }
        
        async function simulateClick() {
            const userId = document.getElementById('userId').value;
            const genre = document.getElementById('genreSelect').value;
            
            try {
                const response = await fetch('/simulate-click', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: parseInt(userId),
                        genre: genre
                    })
                });
                
                const result = await response.json();
                eventCount++;
                
                console.log('Click simulated:', result);
            } catch (error) {
                console.error('Failed to simulate click:', error);
            }
        }
        
        function toggleAutoClick() {
            const button = document.getElementById('autoClickText');
            
            if (autoClickInterval) {
                clearInterval(autoClickInterval);
                autoClickInterval = null;
                button.textContent = 'Start Auto';
            } else {
                autoClickInterval = setInterval(simulateClick, 2000);
                button.textContent = 'Stop Auto';
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
            fetchRecommendations();
        });
    </script>
</body>
</html>